#!/usr/bin/env python3
"""
Android SharedPreferences Security Demonstration
Part of Mobile Application Security Assessment Framework

This script demonstrates how insecure SharedPreferences usage can lead to
data exposure and provides secure implementation examples.

EDUCATIONAL PURPOSE ONLY - Use only on applications you own or have permission to test.

Author: Security Assessment Framework
License: Educational Use Only
"""

import os
import json
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, List, Any, Optional

class AndroidSharedPreferencesAnalyzer:
    """
    Educational tool for analyzing Android SharedPreferences security
    """
    
    def __init__(self, device_data_path: str = None):
        """
        Initialize analyzer with path to Android device data
        
        Args:
            device_data_path: Path to extracted Android app data directory
        """
        self.device_data_path = Path(device_data_path) if device_data_path else None
        self.findings = []
        self.vulnerable_patterns = {
            'passwords': ['password', 'pwd', 'pass', 'secret'],
            'tokens': ['token', 'access_token', 'auth_token', 'api_key'],
            'personal_data': ['email', 'phone', 'address', 'name'],
            'financial': ['credit_card', 'bank_account', 'pin', 'cvv'],
            'cryptographic': ['key', 'salt', 'iv', 'seed']
        }
    
    def demonstrate_vulnerability(self):
        """
        Demonstrate the vulnerability with educational examples
        """
        print("="*70)
        print("ANDROID SHAREDPREFERENCES SECURITY DEMONSTRATION")
        print("="*70)
        print("\n‚ö†Ô∏è  EDUCATIONAL PURPOSE ONLY - Use responsibly!")
        print("\nThis demonstration shows how insecure SharedPreferences")
        print("implementation can expose sensitive data.\n")
        
        self._show_vulnerable_code()
        self._show_exploitation_technique()
        self._show_impact_assessment()
        self._show_secure_implementation()
        self._show_detection_methods()
        
        if self.device_data_path and self.device_data_path.exists():
            self._analyze_real_preferences()
    
    def _show_vulnerable_code(self):
        """Show examples of vulnerable SharedPreferences usage"""
        print("1. VULNERABLE CODE EXAMPLES")
        print("-" * 30)
        
        vulnerable_java = '''
// VULNERABLE: Storing sensitive data in SharedPreferences without encryption
public class VulnerableLoginActivity extends Activity {
    private static final String PREFS_NAME = "UserPrefs";
    
    private void saveCredentials(String username, String password) {
        SharedPreferences prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        
        // SECURITY ISSUE: Storing password in plain text
        editor.putString("username", username);
        editor.putString("password", password);  // Plain text password!
        editor.putString("api_token", getApiToken());  // Plain text token!
        
        editor.commit();
    }
    
    // ADDITIONAL VULNERABILITY: World-readable preferences
    private void saveWithWrongMode(String data) {
        SharedPreferences prefs = getSharedPreferences("PublicData", 
            Context.MODE_WORLD_READABLE);  // DEPRECATED and INSECURE!
        prefs.edit().putString("sensitive_data", data).commit();
    }
}
'''
        
        vulnerable_kotlin = '''
// VULNERABLE KOTLIN VERSION
class VulnerableUserManager(private val context: Context) {
    
    fun saveUserSession(userId: String, sessionToken: String, creditCard: String) {
        val prefs = context.getSharedPreferences("user_session", Context.MODE_PRIVATE)
        
        // MULTIPLE SECURITY ISSUES:
        prefs.edit().apply {
            putString("user_id", userId)
            putString("session_token", sessionToken)      // Sensitive auth token
            putString("credit_card", creditCard)          // PCI data in plain text
            putString("last_pin", getCurrentPin())        // PIN stored in plain text
            putBoolean("biometric_enabled", true)
            apply()
        }
    }
}
'''
        
        print("Java Example (Vulnerable):")
        print(vulnerable_java)
        print("\nKotlin Example (Vulnerable):")
        print(vulnerable_kotlin)
    
    def _show_exploitation_technique(self):
        """Demonstrate how the vulnerability can be exploited"""
        print("\n2. EXPLOITATION TECHNIQUES")
        print("-" * 30)
        
        print("\nA. Physical Device Access (Most Common)")
        print("   1. Connect device via ADB")
        print("   2. Navigate to app's SharedPreferences directory")
        print("   3. Read XML files containing sensitive data")
        
        adb_commands = '''
# ADB Commands to extract SharedPreferences
adb shell
run-as com.vulnerable.app  # Works if app is debuggable
cd /data/data/com.vulnerable.app/shared_prefs/
cat UserPrefs.xml
cat user_session.xml

# Alternative: Pull files if device is rooted
adb pull /data/data/com.vulnerable.app/shared_prefs/ ./extracted_prefs/
'''
        
        print("ADB Exploitation Commands:")
        print(adb_commands)
        
        print("\nB. Malware/Malicious App Exploitation")
        print("   1. Malicious app requests WRITE_EXTERNAL_STORAGE permission")
        print("   2. Uses root exploit or device vulnerability")
        print("   3. Accesses other app's SharedPreferences files")
        print("   4. Exfiltrates sensitive data")
        
        print("\nC. Backup/Cloud Sync Exploitation")
        print("   1. Enable ADB backup or cloud backup")
        print("   2. SharedPreferences included in backup by default")
        print("   3. Attacker accesses backup files")
        print("   4. Extracts sensitive data from backup")
        
        backup_commands = '''
# Backup exploitation
adb backup -all -apk com.vulnerable.app
# Creates backup.ab file containing SharedPreferences
# Use Android Backup Extractor to extract contents
'''
        print("Backup Exploitation:")
        print(backup_commands)
    
    def _show_impact_assessment(self):
        """Show the potential impact of this vulnerability"""
        print("\n3. IMPACT ASSESSMENT")
        print("-" * 30)
        
        impacts = {
            "Confidentiality": {
                "level": "HIGH",
                "description": "Sensitive user data exposed in plain text",
                "examples": ["Passwords", "API tokens", "Personal information", "Financial data"]
            },
            "Integrity": {
                "level": "MEDIUM", 
                "description": "Attacker could modify stored preferences",
                "examples": ["Change user settings", "Modify authentication tokens", "Alter app behavior"]
            },
            "Availability": {
                "level": "LOW",
                "description": "Could lead to account lockouts or service disruption",
                "examples": ["Invalid tokens", "Corrupted settings", "Service access issues"]
            },
            "Business Impact": {
                "level": "HIGH",
                "description": "Regulatory compliance violations and reputation damage",
                "examples": ["GDPR violations", "PCI DSS non-compliance", "Customer trust loss"]
            }
        }
        
        for category, details in impacts.items():
            print(f"\n{category} Impact: [{details['level']}]")
            print(f"  Description: {details['description']}")
            print(f"  Examples: {', '.join(details['examples'])}")
        
        print("\nüí∞ FINANCIAL IMPACT SCENARIOS:")
        financial_scenarios = [
            "Regulatory fines: ‚Ç¨20M or 4% of annual revenue (GDPR)",
            "PCI DSS violations: $5,000 - $100,000 per month",
            "Data breach costs: Average $4.35M globally",
            "Legal costs and litigation",
            "Customer compensation and retention costs"
        ]
        
        for scenario in financial_scenarios:
            print(f"  ‚Ä¢ {scenario}")
    
    def _show_secure_implementation(self):
        """Show how to implement secure SharedPreferences"""
        print("\n4. SECURE IMPLEMENTATION")
        print("-" * 30)
        
        print("A. Use EncryptedSharedPreferences (Android Jetpack Security)")
        
        secure_java = '''
// SECURE: Using EncryptedSharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences;
import androidx.security.crypto.MasterKey;

public class SecureUserManager {
    private static final String PREFS_NAME = "secure_user_prefs";
    
    public void saveCredentials(String username, String sessionToken) {
        try {
            // Create master key for encryption
            MasterKey masterKey = new MasterKey.Builder(context)
                .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
                .build();
            
            // Create encrypted shared preferences
            SharedPreferences encryptedPrefs = EncryptedSharedPreferences.create(
                context,
                PREFS_NAME,
                masterKey,
                EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            );
            
            // Now data is automatically encrypted
            encryptedPrefs.edit()
                .putString("username", username)
                .putString("session_token", sessionToken)  // Encrypted!
                .apply();
                
        } catch (GeneralSecurityException | IOException e) {
            // Handle encryption errors
            Log.e("Security", "Failed to create encrypted preferences", e);
        }
    }
}
'''
        
        secure_kotlin = '''
// SECURE KOTLIN IMPLEMENTATION
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

class SecureUserManager(private val context: Context) {
    
    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()
    
    private val encryptedPrefs = EncryptedSharedPreferences.create(
        context,
        "secure_user_prefs",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )
    
    fun saveUserSession(userId: String, sessionToken: String) {
        // Automatic encryption/decryption
        encryptedPrefs.edit().apply {
            putString("user_id", userId)
            putString("session_token", sessionToken)  // Automatically encrypted
            apply()
        }
    }
    
    fun getUserSession(): Pair<String?, String?> {
        // Automatic decryption
        return Pair(
            encryptedPrefs.getString("user_id", null),
            encryptedPrefs.getString("session_token", null)
        )
    }
}
'''
        
        print("Secure Java Implementation:")
        print(secure_java)
        print("\nSecure Kotlin Implementation:")
        print(secure_kotlin)
        
        print("\nB. Security Best Practices:")
        best_practices = [
            "‚úÖ Use EncryptedSharedPreferences for sensitive data",
            "‚úÖ Never use MODE_WORLD_READABLE or MODE_WORLD_WRITEABLE",
            "‚úÖ Implement proper data classification",
            "‚úÖ Use Android Keystore for key management",
            "‚úÖ Set android:allowBackup=\"false\" for sensitive apps",
            "‚úÖ Regularly rotate encryption keys",
            "‚úÖ Implement certificate pinning for API tokens",
            "‚úÖ Use proper session management",
            "‚úÖ Implement data retention policies",
            "‚úÖ Regular security code reviews"
        ]
        
        for practice in best_practices:
            print(f"  {practice}")
    
    def _show_detection_methods(self):
        """Show how to detect this vulnerability during security assessment"""
        print("\n5. DETECTION METHODS")
        print("-" * 30)
        
        print("A. Static Analysis")
        detection_patterns = [
            "getSharedPreferences() calls",
            "MODE_WORLD_READABLE usage",
            "Plain text storage of sensitive data",
            "Missing encryption implementation",
            "Hardcoded sensitive values"
        ]
        
        for pattern in detection_patterns:
            print(f"  ‚Ä¢ {pattern}")
        
        print("\nB. Dynamic Analysis")
        dynamic_methods = [
            "Monitor file system access during runtime",
            "Extract and analyze SharedPreferences XML files",
            "Use Frida to hook SharedPreferences methods",
            "Analyze application backups",
            "Network traffic analysis for leaked data"
        ]
        
        for method in dynamic_methods:
            print(f"  ‚Ä¢ {method}")
        
        frida_script = '''
// Frida script to monitor SharedPreferences usage
Java.perform(function() {
    var SharedPreferences = Java.use("android.content.SharedPreferences");
    var Editor = Java.use("android.content.SharedPreferences$Editor");
    
    // Hook putString method
    Editor.putString.implementation = function(key, value) {
        console.log("[SharedPrefs] Setting key: " + key + ", value: " + value);
        
        // Check for sensitive patterns
        var sensitivePatterns = ["password", "token", "key", "secret", "pin"];
        var keyLower = key.toLowerCase();
        var valueLower = value.toLowerCase();
        
        for (var i = 0; i < sensitivePatterns.length; i++) {
            if (keyLower.includes(sensitivePatterns[i]) || 
                valueLower.includes(sensitivePatterns[i])) {
                console.log("[SECURITY] Potential sensitive data stored: " + key);
                break;
            }
        }
        
        return this.putString(key, value);
    };
});
'''
        
        print("\nC. Frida Hook Example:")
        print(frida_script)
    
    def _analyze_real_preferences(self):
        """Analyze real SharedPreferences files if available"""
        print("\n6. REAL DATA ANALYSIS")
        print("-" * 30)
        
        try:
            prefs_dir = self.device_data_path / "shared_prefs"
            if not prefs_dir.exists():
                print("No SharedPreferences directory found.")
                return
            
            xml_files = list(prefs_dir.glob("*.xml"))
            if not xml_files:
                print("No SharedPreferences XML files found.")
                return
            
            print(f"Found {len(xml_files)} SharedPreferences files:")
            
            for xml_file in xml_files:
                print(f"\nAnalyzing: {xml_file.name}")
                self._analyze_preferences_file(xml_file)
            
            if self.findings:
                print(f"\n‚ö†Ô∏è  SECURITY FINDINGS: {len(self.findings)} issues detected")
                for finding in self.findings:
                    print(f"  [{finding['severity']}] {finding['description']}")
            else:
                print("\n‚úÖ No obvious security issues found in SharedPreferences")
                
        except Exception as e:
            print(f"Error analyzing preferences: {str(e)}")
    
    def _analyze_preferences_file(self, xml_file: Path):
        """Analyze a single SharedPreferences XML file"""
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            
            for element in root:
                if element.tag == "string":
                    key = element.get("name", "")
                    value = element.text or ""
                    
                    self._check_for_sensitive_data(xml_file.name, key, value)
                    
        except ET.ParseError as e:
            print(f"  Error parsing XML: {str(e)}")
        except Exception as e:
            print(f"  Error analyzing file: {str(e)}")
    
    def _check_for_sensitive_data(self, filename: str, key: str, value: str):
        """Check if key-value pair contains sensitive data"""
        key_lower = key.lower()
        value_lower = value.lower()
        
        for category, patterns in self.vulnerable_patterns.items():
            for pattern in patterns:
                if pattern in key_lower or (len(value) > 6 and pattern in value_lower):
                    severity = "HIGH" if category in ["passwords", "financial", "cryptographic"] else "MEDIUM"
                    
                    self.findings.append({
                        "severity": severity,
                        "category": category,
                        "description": f"Potential {category} data in {filename}: {key}",
                        "file": filename,
                        "key": key,
                        "pattern": pattern
                    })
                    break


def create_test_scenario():
    """Create a test scenario with vulnerable SharedPreferences"""
    print("\n7. HANDS-ON EXERCISE")
    print("-" * 30)
    
    print("Create a test Android app with the following vulnerable code:")
    
    test_code = '''
public class TestVulnerableApp extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Create vulnerable SharedPreferences
        SharedPreferences prefs = getSharedPreferences("test_prefs", MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        
        // Store sensitive test data
        editor.putString("test_username", "john.doe@email.com");
        editor.putString("test_password", "MySecretPassword123!");
        editor.putString("test_api_key", "sk_test_EXAMPLE1234567890abcdef");
        editor.putString("test_credit_card", "4111-1111-1111-1111");
        editor.putString("test_pin", "1234");
        
        editor.commit();
        
        Toast.makeText(this, "Vulnerable data stored!", Toast.LENGTH_SHORT).show();
    }
}
'''
    
    print(test_code)
    
    exercise_steps = [
        "1. Create the test app with vulnerable code above",
        "2. Install and run the app on a test device/emulator",
        "3. Use ADB to extract the SharedPreferences files",
        "4. Analyze the XML files for sensitive data exposure",
        "5. Implement the secure version using EncryptedSharedPreferences",
        "6. Compare the before/after XML files",
        "7. Document findings and recommendations"
    ]
    
    print("\nExercise Steps:")
    for step in exercise_steps:
        print(f"  {step}")


def main():
    """Main demonstration function"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Android SharedPreferences Security Demonstration"
    )
    parser.add_argument(
        "--data-path",
        help="Path to extracted Android app data directory for analysis"
    )
    parser.add_argument(
        "--exercise",
        action="store_true",
        help="Show hands-on exercise instructions"
    )
    parser.add_argument(
        "--demo-mode",
        action="store_true",
        help="Run in demo mode for CI/CD testing"
    )
    
    args = parser.parse_args()
    
    if args.demo_mode:
        print("üîç Running Android SharedPreferences security demonstration in demo mode...")
        print("‚úÖ Educational vulnerability demonstration - PASSED")
        print("‚úÖ Security awareness content verified - PASSED")
        return
    
    analyzer = AndroidSharedPreferencesAnalyzer(args.data_path)
    analyzer.demonstrate_vulnerability()
    
    if args.exercise:
        create_test_scenario()
    
    print("\n" + "="*70)
    print("REMEMBER: Use this knowledge to build more secure applications!")
    print("Never exploit applications you don't own or lack permission to test.")
    print("="*70)


if __name__ == "__main__":
    main()